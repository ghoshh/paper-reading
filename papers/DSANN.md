- 近邻图（PG，Proximity Graph）：两个点之间如果有边，说明两个点离的比较近。不能反推说两个点如果离的近就一定有边。Vamana，HNSW等都算PG。
- 点聚合图（PAG，Point Aggregation Graph):点分成两部分，一部分叫聚合点（Aggregation Point）在这部分点上正常建PG，另一部分点叫残差点（Residual Point），每个残差点只能和一个聚合点连边。就和ivf差不多，聚合点是质心，残差点是这个分区里的其他点。一般这么假设：一共有N个点，按p(0<p<1)的比例采样聚合点
- 动态表示选择（DRS，Dynamic Representation Selection）直接朴素的建PAG会导致分区点的不均衡，论文提出了三点约束：
	1. 理想的分区大小为1/p，(N个点，有Np个分区(聚合点),每个分区大小就是(N/Np)=1/p)。允许一定范围内超过这个范围，设置容量上限为λ/p(λ>=1)
	2. 光限制容量不够，因为某些中心可能还会吸一些其实并不近的点所以 DRS 给每个聚合点 xa 设定一个 聚合半径D[xa] ：残差点 xr 只有在 δ(xr, xa) ≤ D[xa] 时，才允许挂靠。半径是怎么来的？对聚合点xa看它在PG中与邻居的距离分布，取第 γ1 分位的距离作为该点的半径候选 di（如果xa离邻居距离都比较近那局部比较稠密，半径就小一点，反之亦然）但是可能邻居数不够导致di不稳定，于是又加了把所有节点的di收集起来取第 γ2 分位的位置值 d0 作为全局最大半径，最终每个聚合点的半径就是min(d0,d1)
	3. 有的残差点可能依然找不到聚合点可以连接，那就把这个残差点升级成聚合点。
- 具体的建索引流程就是先随机采样聚合点，再在聚合点上建出来PG，按刚才的办法算一下聚合点的半径。再去枚举所有残差点，对于当前的残差点xr，在PG上贪心搜索出k个最近邻。再去看看每个最近邻(聚合点)是不是分区大小和半径都满足要求，满足就让xr和这个最近邻连条边。要是没有能连边的就把xr提升成聚合点。
- 基于图的冗余（GR，Graph-based Redundancy）用来解决边界问题，看看能不能给残差点多加到几个分区里。一个是基于RNG的规则，残差点找多个近的聚合点，一个是路径冗余，看图搜索的 routing path，把沿途节点对应的 partition 作为冗余。
- 并发索引构建（CIC，Concurrent Index Construction），借鉴DiskANN建索引的思路，先把数据拆成c个分区，每个分区里自己建PG，这个可以并行完成。这样只保证“分区内”邻近性，但全局最近邻可能跨分区，所以需要合并阶段补边。先枚举每个分区i的每个点s，对于当前点来说再去枚举其他的分区j，看看如果s到分区j的中心的距离不比离本分区中心远太多（乘一个放宽系数 η）说明分区j不是太远，就可以去分区j搜一下，可以直接调分区j的贪心搜索的接口，找到离s最近的k个最近邻，把所有分区得到的最近邻合并再剪枝一下。这一步合并也是可以并行操作的。整体都可以并行。
![[DSANN-figure2.png]]


- 搜索时的早停策略：自适应分区探测，基于图的结构信息动态地探索分区，并实现早停。每个分区可以看成一个球，半径刚才已经说了，球心就是中心。当前离查询向量最近的分区的中心到查询向量的距离为d，这个分区的半径为ri，假如一个分区j的半径为rj假如分区j到查询向量的距离大于d+ri+rj，那两个球就不会相交了，分区j不可能产生比当前更好的点。
![[DSANN-figure7.png]]
- 搜索流程：每次从候选集中还没被访问的点中拿出来一个离查询向量q最近的向量p*,把p*所有邻居加到候选集来，标记p*访问过，判断是否满足$δ(q,p^*)≥ρ⋅(δ(v^*,p^*)+D[v^∗]+D[p^∗])$ v*就是目前见过离q最近的聚合点，就是看看刚才的早停策略满不满足，满足了就break了。不能早停就从候选集中拿出来还没从磁盘加载的且离q最近的聚合点，把它所在的分区的点都加载出来，这里可以异步执行了，然后把分区所有的点放到结果集了。最后返回结果集里的k个最近的向量。