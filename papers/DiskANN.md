- 稀疏邻域图（SNG，Sparse Neighborhood Graph,）受RNG的启发，构建方法是对于每个点p，令集合S为所有点除去p，每次选一个当前S里离p最近的点p*，并把S中所有满足d(p, p')>d(p*,p')的点p'删掉。一直这么操作。假如p在(0,0),p*在(1,0)设p'为(x,y)可以算出来x>=1/2，把所有x>=1/2的点从S中删掉。
- RobustPrune，就是剪枝算距离的时候，加一个系数α， d(p, p')>αd(p*,p')，解方程可以得到区域是个圆，α越大区域越小，剪枝的力度越小。
- Vamana 索引构建：先随机初始化一张图，起点s为所有向量的“中位点”，之后随机遍历所有点p，贪心搜索一下得到路径所有的点集合V，然后调用RobustPrune，让p连边，集合V的点也往p连边，要是度数超了就也调用一下然后调用RobustPrune。遍历两遍，第一遍α=1，第二遍α>=1，用户自己定义。
- DiskANN的构建过程，由于内存不够，所以如何构建图呢？可以kmeans分成几个分片，每个分片自己建图，让每个点属于多个分片。每个分片点没那么多了，就可以在内存构建了，这里用的是原始向量。之后再把所有图的边并一下，合并成一张大图。
- 搜索的时候原始向量都不能放到内存中，又怎么算查询点和候选点都距离呢？可以用PQ量化，在内存放所有点的压缩向量，把图的结构和原始向量放到硬盘里。硬盘上，第i个点顺序存：第i个点都原始向量和最多R个邻居的id。邻居不够R个用0填充。
- 因为索引数据都在硬盘上，为了减少磁盘访问次数和减少磁盘读写请求，DIskANN提出了两种优化策略。一个是起点开始C跳内的点常驻内存，一般C为3~4.另一个是beam search，搜索p时，如果p的邻居不在缓存，需要去磁盘加载p的邻居，可以一次加载W个未访问点的邻居信息，因为一次少量的 SSD 随机访问操作和一次 SSD 单扇区访问操作耗时差不多。