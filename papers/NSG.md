- **单调路径（Monotonic Path** ：图G中任意两点p,q,p到q的路径表示为v1,v2,v3..vk，(v1=p,vk=q)，满足对于任意的i(1<=i<k),有$δ(v_i,q)>δ(v_{i+1}, q)$ δ(x, y)表示点x和点y的距离。
-  **单调搜索网络（MSNET，Monotonic Search Network）**：一个图如果任意两个点p,q都有存在至少一条单调路径的图，这个图就是单调搜索网络。
- 定理1：单调搜索网络中的任意两点p,q，都可以用best-first的方式找到p到q的单调路径。（就是经典的贪心搜索方法）
- 引理1：图G是MSNET当且仅当任意两个点p,q,至少存在一条边pr满足$r ∈ B(q, δ(p, q))$ ,B(x,len)的含义是以x为圆心，len为半径的圆。
	看下图,p到q的单调路径中,pq,s都是路径上的点，可以以q为圆心，路径上的点的长度为半径画圆，路径的下一个点一定在这个圆内部。
 ![[./img/NSG-figure2.png]]

- 定理2：在合理分布的数据下：${E}[\text{路径长度}] = O\!\left(\frac{n^{1/d}\log(n^{1/d})}{\Delta r}\right))$，实际效果 ≈ O(log⁡n)
- **相对邻域图（RNG，Relative Neighborhood Graph）**：先来定义一下$lune_{pq}​=B(p,δ(p,q))∩B(q,δ(p,q))$,表示分别以p,q为圆心,|pq|为半径的圆的交集区域。对于任意两个点p,q如果$lune_{pq}$区域内没有其他点，那么边pq属于RNG。可以理解把RNG理解成把点集中构成的所有的三角形的最长边删除掉。假如有p,q,r三个点，如果pq是三角形中最长的，那就可以走p->r->q，而不是p->q。已有研究证明 RNG 并不具备构成 MSNET 所需的充分边集，太稀疏了。因此无法保证搜索路径长度，其搜索过程可能出现严重绕行。
- 本文提出的：**单调相对邻域图（MRNG，Monotonic Relative Neighborhood Graph）**：有向图，边集满足：对于任意有向边 $\overrightarrow{pq}$​，当且仅当$lune_{pq}∩S=∅$或$∀r∈(lune_{pq}∩S),\overrightarrow{pq}​\notin MRNG$。直观理解就是对于边pq，如果没有点可以和pq组合成三角形并且让pq是最长变，或者假如让pq作为最长边，再去找所有可以和pq作为一个三角形的点r，假如p到r都没连边的话，那么就可以把p到q连上边了。
- 定理3：MRNG是MSNET，证明没看，也看不懂:(
- 引理2：MRNG的最大出度是与n无关的常数。

- 下图a是RNG，b是MRNG![[NSG-figure3.png]]
-
- MRNG的构建复杂度也比较高，为$O(n^2logn+n^2c)$。
- 提出了 **NSG（Navigating Spreading-out Graph）** 来近似 MRNG。构建流程：
  1. 构建初始 KNN 图
  2. 找到离质心（所有向量在每个维度的平均值）最近的存在的向量n作为起点（Navigating Node）从它出发到任意区域的搜索路径更短、稳定。
  3. 依次枚举所有向量v，以n为起点，v为查询向量进行贪心搜索得到路径上的点以及v在knn图上的k近邻放到候选集合E里，再按到v的距离从小到大排序。接下来挑出来最多m条边，流程是先把最近的点加到结果集R，然后依次判断剩下的每个点p，看看p是否和结果集里的每个点r冲突，不冲突就加到结果集R里。
  4. 上述操作可能会因为限制出度而剪掉长边导致图不联通，所以再去以n作为根在图上dfs，如果还有点y没被访问到，就从n出发贪心搜索，y作为查询向量，找到离树外点最近的点x，让x连到y上。
  搜索阶段也是从n为起点开始搜。

